{
    "controller": "_B=False\n_A=1.\nfrom microbit import run_every,pin13,pin14,pin15,pin16,pin8,pin1,pin2,pin12,button_a,button_b,sleep\nclass _Controller_Button:\n\tdef __init__(A,pin):B=pin;A._pin=B;A.previous_state=0;A._press_count=0;A._pressed_before=_B;B.set_pull(B.PULL_UP)\n\tdef _f3(A):\n\t\tB=1-A._pin.read_digital()\n\t\tif B==1 and A.previous_state==0:A._press_count+=1;A._pressed_before=True\n\t\tA.previous_state=B\n\tdef is_pressed(A):return _B if A._pin.read_digital()else True\n\tdef was_pressed(A):B=A._pressed_before;A._pressed_before=_B;return B\n\tdef get_presses(A):B=A._press_count;A._press_count=0;return B\nclass _Controller_Analog_Stick:\n\tdef __init__(A,pinX,pinY,pinZ):A.pin_x=pinX;A.pin_y=pinY;A.button_z=_Controller_Button(pinZ);A.dead_zone=.01;A.center_x=0;A.center_y=0;A.min_x=-1;A.max_x=1;A.min_y=-1;A.max_y=1\n\tdef calibrate(A,dead_zone,center_x=.0,center_y=.0,x_min=-_A,x_max=_A,y_min=-_A,y_max=_A):A.dead_zone=min(.2,max(.01,dead_zone));A.center_x=min(.4,max(-.4,center_x));A.center_y=min(.5,max(-.5,center_y));A.min_x=min(-.5,max(-_A,x_min));A.max_x=min(_A,max(.5,x_max));A.min_y=min(-.5,max(-_A,y_min));A.max_y=min(_A,max(.5,y_max))\n\tdef _f5(C,value,center,v_min,v_max):\n\t\tB=center;A=value-_A-B\n\t\tif abs(A)-C.dead_zone/2.>.0:\n\t\t\tif A<.0:A=A/abs(v_min-B)\n\t\t\telse:A=A/abs(v_max-B)\n\t\tA=min(_A,max(-_A,A));A=.0 if abs(A)<=C.dead_zone else A;return A\n\tdef get_x(A):B=A.pin_x.read_analog()/512.;C=A._f5(B,A.center_x,A.min_x,A.max_x);return C\n\tdef get_y(A):B=A.pin_y.read_analog()/512.;C=A._f5(B,A.center_y,A.min_y,A.max_y);return C\n\tdef get_z(A):return 1 if A.button_z.is_pressed()else 0\n\tdef is_pressed(A):return A.button_z.is_pressed()\n\tdef was_pressed(A):return A.button_z.was_pressed()\n\tdef get_presses(A):return A.button_z.get_presses()\ndef vibrate(state):pin12.write_digital(state)\njoystick=_Controller_Analog_Stick(pin1,pin2,pin8)\nbutton_z=joystick.button_z\nbutton_c=_Controller_Button(pin13)\nbutton_green=button_c\nbutton_d=_Controller_Button(pin14)\nbutton_yellow=button_d\nbutton_e=_Controller_Button(pin15)\nbutton_red=button_e\nbutton_f=_Controller_Button(pin16)\nbutton_blue=button_f\ntrigger_left=button_a\ntrigger_right=button_b\ndef _f1():global button_c;global button_d;global button_e;global button_f;global joystick;button_c._f3();button_d._f3();button_e._f3();button_f._f3();joystick.button_z._f3()\nrun_every(_f1,days=0,h=0,min=0,s=0,ms=33)",
    "huskylens": "_E='Invalid model_id. Must be number in range [0,4]'\n_D='Error: ID must be in range from 1 to 255.'\n_C=None\n_B=True\n_A=False\nfrom microbit import i2c,sleep,running_time\nimport math\n_g1=['FaceRecognition','ObjectTracking','ObjectRecognition','LineTracking','ColorRecognition','TagRecognition','ObjectClassification','QRRecognition','BarcodeRecognition']\nclass Request_Command:KNOCK=44;ALGORITHM=45;ALL=32;BLOCKS=33;BLOCKS_LEARNED=36;BLOCKS_OF_ID=39;ARROWS=34;ARROWS_LEARNED=37;ARROWS_OF_ID=40;LEARNED=35;ALL_OF_ID=38;LEARN=54;FORGET=55;CUSTOM_LABEL=47;CUSTOM_TEXT=52;CLEAR_TEXT=53;SAVE_MODEL=50;LOAD_MODEL=51;SAVE_PHOTO=48;SAVE_SCREENSHOT=57;IS_PRO=59;VERSION=60\nclass Return_Code:ANY=1;OK=46;BUSY=61;INFO=41;BLOCK=42;ARROW=43;IS_PRO=59;NEED_PRO=62\nclass Algorithm:FACE_RECOGNITION=0;OBJECT_TRACKING=1;OBJECT_RECOGNITION=2;LINE_TRACKING=3;COLOR_RECOGNITION=4;TAG_RECOGNITION=5;OBJECT_CLASSIFICATION=6;QR_RECOGNITION=7;BARCODE_RECOGNITION=8\nclass Block:\n\tdef __init__(A,x,y,width,height,id):A.x=x;A.y=y;A.width=width;A.height=height;A.id=id\n\tdef _f2(A):return'Block: ID_'+str(A.id)+' Pos: ('+str(A.x)+' '+str(A.y)+') Size: ('+str(A.width)+' '+str(A.height)+')'\nclass Arrow:\n\tdef __init__(A,x_tail,y_tail,x_head,y_head,id):A.x_tail=x_tail;A.y_tail=y_tail;A.x_head=x_head;A.y_head=y_head;A.id=id\n\tdef get_direction(A):\n\t\tC=A.x_head-A.x_tail;D=A.y_head-A.y_tail;B=90-math.degrees(math.atan2(D,C))\n\t\tif B<0:B=B+360\n\t\treturn int(B)\n\tdef _f2(A):return'Arrow: ID_'+str(A.id)+' ('+str(A.x_tail)+' '+str(A.y_tail)+')->('+str(A.x_head)+' '+str(A.y_head)+')'\ndef byte_checksum(byte_list):return sum(byte_list)&255\ndef hexify(byte_array):\n\tA=byte_array\n\tif len(A)==0:return''\n\treturn'0x'+''.join('{:02x}'.format(A)for A in A)\nclass Huskylens:\n\tI2C_ADDR=50\n\tdef __init__(A):A.learned_slot_count=0;A.id_slots={};A.id_names={};A.algorithm=Algorithm.OBJECT_TRACKING;A.clear_texts();A.pro_enabled=A.is_pro()\n\tdef initialize(A):\n\t\tB=_A\n\t\tfor E in range(5):\n\t\t\tA.knock();B,F=A.get_response(Return_Code.OK)\n\t\t\tif B:break\n\t\tif B>0:\n\t\t\tC=A.clear_texts();D=A.set_algorithm(Algorithm.OBJECT_TRACKING)\n\t\t\tif C and D:print('Initialization successful!');return _B\n\t\t\telse:print(\"Initialization Failed. Couldn't change Algorithm\");return _A\n\t\telse:print('Initialization Failed. Please check connection to Huskylens.');return _A\n\tdef send_request(D,command,data=_C):\n\t\tB=data;A=bytearray(b'U\\xaa\\x11\\x00\\x00');A[3]=0 if B is _C else len(B);A[4]=command\n\t\tif B:\n\t\t\tfor C in B:A.append(C)\n\t\tA.append(byte_checksum(A));i2c.write(Huskylens.I2C_ADDR,A);sleep(50)\n\tdef get_response(K,return_code=Return_Code.ANY,timeout=500):\n\t\tC=return_code;A=bytearray(b'U\\x00\\x00\\x00\\x00');I=running_time()\n\t\twhile running_time()-I<timeout:\n\t\t\tD=i2c.read(Huskylens.I2C_ADDR,1)[0]\n\t\t\tif D==85:break\n\t\tif D!=85:return-1,[]\n\t\tfor J in range(4):A[J+1]=i2c.read(Huskylens.I2C_ADDR,1)[0]\n\t\tif A[0:3]!=b'U\\xaa\\x11':return-2,[]\n\t\tE=A[3];F=A[4];B=[]\n\t\tif E>0:G=i2c.read(Huskylens.I2C_ADDR,E+1);B=G[0:-1];H=G[-1]\n\t\telse:H=ord(i2c.read(Huskylens.I2C_ADDR,1))\n\t\tif H!=byte_checksum(list(A)+B):return-3,[]\n\t\tif C==Return_Code.ANY or F==C:return F,B\n\t\telse:return 0,B\n\tdef knock(A):A.send_request(Request_Command.KNOCK)\n\tdef set_algorithm(B,algorithm):\n\t\tA=algorithm\n\t\tif(A==Algorithm.QR_RECOGNITION or A==Algorithm.BARCODE_RECOGNITION)and not B.pro_enabled:raise RuntimeError('Error: Huskylens PRO version is required for algorithm ',_g1[A]);return _A\n\t\tD=[A,0];B.send_request(Request_Command.ALGORITHM,D);C,E=B.get_response(Return_Code.OK)\n\t\tif C>0:print('Current Algorithm:',_g1[A]);B.algorithm=A\n\t\treturn _B if C>0 else _A\n\tdef get_all(A):return A._f7(Request_Command.ALL)\n\tdef get_all_learned(A):return A._f7(Request_Command.LEARNED)\n\tdef get_all_with_id(A,id):\n\t\tif id<=0 or id>255:raise RuntimeError(_D)\n\t\treturn A._f7(Request_Command.ALL_OF_ID,id)\n\tdef get_one(A):B=A._f7(Request_Command.ALL);return A._f8(B)\n\tdef get_one_learned(A):B=A._f7(Request_Command.LEARNED);return A._f8(B)\n\tdef get_one_with_id(A,id):\n\t\tif id<=0 or id>255:raise RuntimeError(_D)\n\t\tB=A._f7(Request_Command.ALL_OF_ID,id);return A._f8(B)\n\tdef attach_label(A,id,name):\n\t\tB=name\n\t\tif A.algorithm==Algorithm.OBJECT_TRACKING or A.algorithm==Algorithm.LINE_TRACKING:C=A._f6(1,B)\n\t\telif A.algorithm==Algorithm.FACE_RECOGNITION or A.algorithm==Algorithm.TAG_RECOGNITION or A.algorithm==Algorithm.OBJECT_CLASSIFICATION or A.algorithm==Algorithm.OBJECT_RECOGNITION:\n\t\t\tD=A.id_slots.get(id)\n\t\t\tif D==_C:raise RuntimeError(\"Can't attach a name to an unlearned ID number\")\n\t\t\tA.id_names[id]=B;C=_B\n\t\t\tfor E in D:F=A._f6(E,B);C=C and F>0\n\t\telse:A.id_names[id]=B;C=A._f6(id,B)\n\t\treturn _B if C>0 else _A\n\tdef clear_labels(A):\n\t\tA.id_names.clear()\n\t\tfor B in range(10):A._f6(B,'')\n\tdef add_text(E,text,position_x,position_y):\n\t\tC=position_y;B=position_x;D=bytes(text,'utf-8')\n\t\tif len(D)>19:raise RuntimeError('Custom Text must be less than 20 bytes long.')\n\t\tif B>300 or B<0 or C<35 or C>240:raise RuntimeError(\"Custom Text can't be placed outside of screen pixel size.\")\n\t\tA=[len(D)];A.append(255 if B>255 else 0);A.append(B%255);A.append(240-C);A.extend(list(D));E.send_request(Request_Command.CUSTOM_TEXT,A);F,G=E.get_response(Return_Code.OK);return _B if F>0 else _A\n\tdef clear_texts(A):A.send_request(Request_Command.CLEAR_TEXT);B,C=A.get_response(Return_Code.OK);return _B if B>0 else _A\n\tdef learn(A,id,name=_C):\n\t\tif id<=0 or id>255:raise RuntimeError('Parameter ID for learned item must be in range [0,255]')\n\t\tif A.algorithm==Algorithm.OBJECT_TRACKING or A.algorithm==Algorithm.LINE_TRACKING:id=1\n\t\tC=500\n\t\tif A.algorithm==Algorithm.OBJECT_CLASSIFICATION:C=1000\n\t\tA.send_request(Request_Command.LEARN,[id,0]);B,E=A.get_response(Return_Code.OK,C)\n\t\tif B>0:\n\t\t\tA.learned_slot_count+=1\n\t\t\tif not id in A.id_slots:A.id_slots[id]=[A.learned_slot_count]\n\t\t\telse:A.id_slots[id].append(A.learned_slot_count)\n\t\t\tD=A.id_names.get(id)\n\t\t\tif D!=_C:B=A.attach_label(A.learned_slot_count,D)\n\t\t\telif name!=_C:B=A.attach_label(id,name)\n\t\treturn _B if B>0 else _A\n\tdef forget(A):\n\t\tA.send_request(Request_Command.FORGET);B,C=A.get_response(Return_Code.OK)\n\t\tif B:A.learned_slot_count=0;A.id_slots.clear()\n\t\treturn _B if B else _A\n\tdef save_photo(A):A.send_request(Request_Command.SAVE_PHOTO);B,C=A.get_response(Return_Code.OK,1000);return _B if B>0 else _A\n\tdef save_screenshot(A):A.send_request(Request_Command.SAVE_SCREENSHOT);B,C=A.get_response(Return_Code.OK,1000);return _B if B>0 else _A\n\tdef save_model(B,model_id):\n\t\tA=model_id\n\t\tif A<0 or A>4:raise RuntimeError(_E)\n\t\tB.send_request(Request_Command.SAVE_MODEL,[A,0]);C,D=B.get_response(Return_Code.OK,1000);print('Model saving: Check Huskylens screen for Result!\\n\\tModel name:',_g1[B.algorithm]+'_Backup_'+str(A)+'.conf');return _B if C>0 else _A\n\tdef load_model(B,model_id):\n\t\tA=model_id\n\t\tif A<0 or A>4:raise RuntimeError(_E)\n\t\tB.send_request(Request_Command.LOAD_MODEL,[A,0]);C,D=B.get_response(Return_Code.OK,1000);print('Model Loading: Check Huskylens screen for Result!');return _B if C>0 else _A\n\tdef is_pro(A):A.send_request(Request_Command.IS_PRO);B,C=A.get_response(Return_Code.IS_PRO);return bool(C[0])if B>0 else _A\n\tdef _f6(C,id,name):\n\t\tA=bytes(name,'utf-8')\n\t\tif len(A)>19:raise RuntimeError('Custom Name must be less than 20 bytes long.')\n\t\tB=[id,len(A)+1];B.extend(list(A));B.append(0);C.send_request(Request_Command.CUSTOM_LABEL,B);D,E=C.get_response(Return_Code.OK);return _B if D>0 else _A\n\tdef _f7(B,request_command,id=-1):\n\t\tI=_C if id<0 else[id,0];B.send_request(request_command,I);G,H=B.get_response(Return_Code.INFO)\n\t\tif not G:raise RuntimeError('Failed to request results. Got answer:'+str(G))\n\t\tJ=H[0]+H[1]*255;C=0;D=[]\n\t\twhile C<J:\n\t\t\tE,A=B.get_response(Return_Code.ANY)\n\t\t\tif E==Return_Code.BLOCK and B.algorithm!=3:K=A[0]+A[1]*255;L=240-A[2]+A[3]*255;M=A[4]+A[5]*255;N=A[6]+A[7]*255;F=A[8];O=Block(K,L,M,N,F);D.append(O);C+=1\n\t\t\telif E==Return_Code.ARROW:P=A[0]+A[1]*255;Q=240-A[2]+A[3]*255;R=A[4]+A[5]*255;S=240-A[6]+A[7]*255;F=A[8];T=Arrow(P,Q,R,S,F);D.append(T);C+=1\n\t\t\telif E==0:return[]\n\t\treturn D\n\tdef _f8(E,results):\n\t\tC=_C;D=440\n\t\tfor A in results:\n\t\t\tB=0\n\t\t\tif E.algorithm==Algorithm.LINE_TRACKING:B=abs(A.x_tail+(A.x_tail-A.x_head)//2-160)+abs(A.y_tail+(A.y_tail-A.y_head)//2-120)\n\t\t\telse:B=abs(A.x-160)+abs(A.y-120)\n\t\t\tif B<D:C,D=A,B\n\t\treturn C",
    "mbalarm": "import music\n_g1=['c6:1','r','c6,1','r','r','r']\ndef setAlarm(on):\n\tif on:music.play(_g1,wait=False,loop=True)\n\telse:music.stop()\ndef beep():music.pitch(2000,200,wait=False)",
    "mbbitbot": "from microbit import*\nfrom neopixel import*\nfrom utime import ticks_us,sleep_us\n_g1=200\n_g2=12\n_g3=NeoPixel(pin13,_g2)\n_g4=0\n_g5=0\ndef w(leftforward,leftbackward,rightforward,rightbackward):\n\tif leftforward>0 or rightforward>0:pin16.write_analog(leftforward+_g4);pin8.write_analog(leftbackward);pin14.write_analog(rightforward-_g4);pin12.write_analog(rightbackward)\n\telif leftbackward>0 or rightbackward>0:pin16.write_analog(leftforward);pin8.write_analog(leftbackward+_g4);pin14.write_analog(rightforward);pin12.write_analog(rightbackward-_g4)\n\telif leftforward==0 and rightforward==0 and leftbackward==0 and rightbackward==0:pin16.write_analog(0);pin8.write_analog(0);pin14.write_analog(0);pin12.write_analog(0)\ndef forward():w(_g1,0,_g1,0)\ndef backward():w(0,_g1,0,_g1)\ndef stop():w(0,0,0,0)\ndef right():w(0,_g1,_g1,0)\ndef left():w(_g1,0,0,_g1)\ndef set_led(pos,red,green,blue):_g3[pos]=red,green,blue;_g3.show()\ndef fill(red,green,blue):\n\tfor i in range(_g2):_g3[i]=red,green,blue\n\t_g3.show()\ndef getDistance():\n\tpin15.write_digital(1);sleep_us(10);pin15.write_digital(0);pin15.set_pull(pin15.NO_PULL)\n\twhile pin15.read_digital()==0:0\n\tstart=ticks_us()\n\twhile pin15.read_digital()==1:0\n\tend=ticks_us();echo=end-start;distance=int(.01715*echo);return distance\ndef calibrate(offset,differential=0):global _g4;global _g5;global _g8;_g5=max(min(int(offset),50),-50);_g4=max(min(int(differential),50),-50);_g8=max(min(arcScaling,50),-50);setSpeed(_g1/1023*100)\ndef setSpeed(percent):global _g1;speed=percent/100*1023;speed+=_g5/100*1023;speed=min(max(speed,0),1023);_g1=speed\ndef getLine(bit):\n\tmask=1<<bit;value=0\n\ttry:value=i2c.read(28,1)[0]\n\texcept OSError:pass\n\tif value&mask>0:return 1\n\telse:return 0\ndef getLight(index):\n\tif index==0:return pin1.read_analog()\n\telif index==1:return pin2.read_analog()\ndef leftArc(radius):speed=_g1;inner_wheel_speed=speed*(radius/(radius+1));w(inner_wheel_speed,0,speed,0)\ndef rightArc(radius):speed=_g1;inner_wheel_speed=speed*(radius/(radius+1));w(speed,0,inner_wheel_speed,0)",
    "mbglow": "from microbit import*\n_g1=0\n_g2=0\n_g3=0\n_g4=50\n_g5=True\n_g6=False\ndef makeGlow():global _g6;display.set_pixel(2,2,9);_g6=True\ndef clear():display.clear()\ndef forward():_f1(1)\ndef back():_f1(-1)\ndef right(angle):global _g3;_g3=(_g3+angle)%360\ndef left(angle):right(-angle)\ndef setPos(x,y):global _g1,_g2;_g1=x;_g2=y;_f2()\ndef getPos():return _g1,_g2\ndef setSpeed(speed):global _g4;_g4=speed\ndef showTrace(enable):global _g5;_g5=enable\ndef isLit():return display.get_pixel(_g1+2,4-(_g2+2))==9\ndef _f1(s):\n\tglobal _g1,_g2;sleep(2000-_g4*20);d=_g3//45\n\tif d in[1,2,3]:_g1+=s\n\tif d in[5,6,7]:_g1-=s\n\tif d in[0,1,7]:_g2+=s\n\tif d in[3,4,5]:_g2-=s\n\t_f2()\ndef _f2():\n\tif not _g6:print('Use \"makeGlow()\" to create a Glow.');raise Exception('Glow not initialized.')\n\tif not _g5:display.clear()\n\tif-2<=_g1<=2 and-2<=_g2<=2:display.set_pixel(_g1+2,4-(_g2+2),9)",
    "mbled": "from neopixel import*\nimport gc\nfrom microbit import pin2\n_g1=24\n_g2=NeoPixel(pin2,_g1)\ndef fill(red,green,blue):\n\tfor i in range(_g1):_g2[i]=red,green,blue\n\t_g2.show()\ndef set_led(pos,red,green,blue):_g2[pos]=red,green,blue;_g2.show()\ndef clear():_g2.clear()\ndef shift_by(amount):\n\tshifted_copy=[None]*_g1\n\tfor n in range(0,_g1):next_i=(n+amount)%_g1;shifted_copy[n]=_g2[next_i]\n\tfor n in range(0,_g1):_g2[n]=shifted_copy[n]\n\t_g2.show()\ndef lerp_RGB(r1,g1,b1,r2,g2,b2,percent):\n\tif percent<.0 or percent>1e2:raise RuntimeError(\"Argument 'percent' must be between 0 and 100.\")\n\tred=max(0,min(255,round(r1+(r2-r1)*(percent/1e2))));green=max(0,min(255,round(g1+(g2-g1)*(percent/1e2))));blue=max(0,min(255,round(b1+(b2-b1)*(percent/1e2))));return red,green,blue",
    "mbmarsrover": "from microbit import*\nfrom neopixel import*\nimport utime\n_g1=[0,9,11,13,15]\n_g2=[0,0,0,0,0]\n_g3=False\n_g4=4\n_g5=NeoPixel(pin2,_g4)\n_g6=50\n_g7=40\n_g8=40\n_g9=0\n_g10=0\n_g11=0\n_g12=500\n_g13=29.1\ndef _f1(dirL,powerL,dirR,powerR):pinsL=pin1,pin12;pinsR=pin8,pin0;pinsL[dirL].write_analog(powerL);pinsL[1-dirL].write_analog(0);pinsR[dirR].write_analog(powerR);pinsR[1-dirR].write_analog(0)\ndef _f2(side,direction,power):\n\tif side==0:pins=pin1,pin12\n\telif side==1:pins=pin8,pin0\n\tpins[direction].write_analog(power);pins[1-direction].write_analog(0)\ndef _f3(r):\n\touterSpeed=_g6;rCm=int(r*100);threshold=outerSpeed-max(rCm+20,40)\n\tif threshold<=0:outerSpeed=min(max(rCm+40,40),100)\n\treducedSpeed=0\n\tif rCm>=4:flattening=(100-outerSpeed)//2;reducedSpeed=(rCm*10-35)/(rCm*(11+(_g11-4)/10)+90+flattening);reducedSpeed=reducedSpeed*outerSpeed\n\tinnerByte=_f6(int(reducedSpeed),0);outerByte=_f6(int(outerSpeed),0);return innerByte,outerByte\ndef _f4():global _g3;_g3=True;i2cData=bytearray(2);i2cData[0]=0;i2cData[1]=16;i2c.write(64,i2cData);i2cData[0]=254;i2cData[1]=101;i2c.write(64,i2cData);i2cData[0]=0;i2cData[1]=129;i2c.write(64,i2cData)\ndef _f5(pin,value,timeout):\n\tstart_time=utime.ticks_us()\n\twhile pin.read_digital()!=value:\n\t\tif utime.ticks_diff(utime.ticks_us(),start_time)>timeout:return 0\n\tstart_time=utime.ticks_us()\n\twhile pin.read_digital()==value:\n\t\tif utime.ticks_diff(utime.ticks_us(),start_time)>timeout:return 0\n\treturn utime.ticks_diff(utime.ticks_us(),start_time)\ndef calibrate(offset,differential=0,arcScaling=0):global _g10;global _g9;global _g11;_g9=max(min(int(offset),500),-50);_g10=max(min(int(differential),150),-150);_g11=max(min(arcScaling,50),-15);setSpeed(_g6)\ndef setSpeed(speed):\n\tglobal _g6;global _g7;global _g8;_g6=int(min(max(speed,0),100));powerValue=_f6(_g6,_g9);boost=round((1-_g6/100)*abs(_g10))if _g6>0 else 0;reduction=round(_g6/100*abs(_g10))\n\tif _g10>0:_g7=powerValue-reduction;_g8=powerValue+boost\n\telse:_g7=powerValue+boost;_g8=powerValue-reduction\ndef _f6(speed,offset):analogValue=int(speed*1023/100)+offset;return min(max(analogValue,0),1023)\ndef stop():_f1(0,0,0,0)\ndef forward():_f1(0,_g7,0,_g8)\ndef backward():_f1(1,_g7,1,_g8)\ndef setServo(servoNum,angle):\n\tglobal _g1,_g3\n\tif _g3==False:_f4()\n\toffsetNum=servoNum;servoNum=_g1[servoNum];i2cData=bytearray(2);start=0;angle=max(min(angle,90),-90);stop=396+(angle+_g2[offsetNum])*223/90;i2cData[0]=6+servoNum*4+2;i2cData[1]=int(stop)+255;i2c.write(64,i2cData);i2cData[0]=6+servoNum*4+3;i2cData[1]=int(stop)>>8;i2c.write(64,i2cData)\ndef clearServos():setServo(0,0);setServo(1,0);setServo(2,0);setServo(3,0);setServo(4,0);sleep(500)\ndef steer(angle):angle=max(min(angle,45),-45);setServo(1,angle);setServo(2,-angle);setServo(3,-angle);setServo(4,angle);sleep(500)\ndef setLED(pos,red,green,blue):_g5[pos]=red,green,blue;_g5.show()\ndef fill(red,green,blue):\n\tfor i in range(_g4):_g5[i]=red,green,blue\n\t_g5.show()\ndef getDistance():\n\ttrig=pin13;echo=pin13;d=10;trig.set_pull(trig.NO_PULL)\n\tfor _ in range(10):\n\t\ttrig.write_digital(0);utime.sleep_us(2);trig.write_digital(1);utime.sleep_us(10);trig.write_digital(0);duration=_f5(echo,1,_g12*_g13)\n\t\tif duration>0:d=duration;break\n\treturn round(d/_g13)\ndef calibrateServo(pos,angleDifferential):global _g2;angleDifferential=max(min(angleDifferential,90),-90);_g2[pos]=angleDifferential;clearServos()",
    "mbminibit": "from microbit import*\nfrom neopixel import*\nimport utime\n_g1=4\n_g2=NeoPixel(pin13,_g1)\n_g3=50\n_g4=90\n_g5=90\n_g6=0\n_g7=0\n_g8=0\n_g9=500\n_g10=29.1\ndef _f1(dirL,powerL,dirR,powerR):pin8.write_analog(powerL if dirL==1 else 0);pin12.write_analog(0 if dirL==1 else powerL);pin16.write_analog(0 if dirR==1 else powerR);pin14.write_analog(powerR if dirR==1 else 0)\ndef _f2(pin,value,timeout):\n\tstart_time=utime.ticks_us()\n\twhile pin.read_digital()!=value:\n\t\tif utime.ticks_diff(utime.ticks_us(),start_time)>timeout:return 0\n\tstart_time=utime.ticks_us()\n\twhile pin.read_digital()==value:\n\t\tif utime.ticks_diff(utime.ticks_us(),start_time)>timeout:return 0\n\treturn utime.ticks_diff(utime.ticks_us(),start_time)\ndef _f3(r):\n\touterSpeed=_g3\n\tif r>0:innerSpeed=outerSpeed*max(.2,min(1,1-r/100))\n\telse:innerSpeed=0\n\tinnerByte=_f4(int(innerSpeed),0);outerByte=_f4(int(outerSpeed),0);return innerByte,outerByte\ndef _f4(speed,offset):analogValue=int(speed*255/100)+offset;return min(max(analogValue,0),255)\ndef calibrate(offset,differential=0,arcScaling=0):global _g7;global _g6;global _g8;_g6=max(min(int(offset),100),-10);_g7=max(min(int(differential),150),-150);_g8=max(min(arcScaling,50),-15);setSpeed(_g3)\ndef setSpeed(speed):\n\tglobal _g3;global _g4;global _g5;_g3=int(min(max(speed,0),100));powerByte=_f4(_g3,_g6);boost=round((1-_g3/100)*abs(_g7))if _g3>0 else 0;reduction=round(_g3/100*abs(_g7))\n\tif _g7>0:_g4=powerByte-reduction;_g5=powerByte+boost\n\telse:_g4=powerByte+boost;_g5=powerByte-reduction\ndef stop():_f1(0,0,0,0)\ndef forward():_f1(0,_g4,0,_g5)\ndef backward():_f1(1,_g4,1,_g5)\ndef left():_f1(1,_g4,0,_g5)\ndef right():_f1(0,_g4,1,_g5)\ndef rightArc(radius):inner,outer=_f3(radius);_f1(0,outer,0,inner)\ndef leftArc(radius):inner,outer=_f3(radius);_f1(0,inner,0,outer)\ndef setLED(pos,red,green,blue):_g2[pos]=red,green,blue;_g2.show()\ndef fill(red,green,blue):\n\tfor i in range(_g1):_g2[i]=red,green,blue\n\t_g2.show()\ndef getDistance():\n\ttrig=pin15;echo=pin15;d=10;trig.set_pull(trig.NO_PULL)\n\tfor _ in range(10):\n\t\ttrig.write_digital(0);utime.sleep_us(2);trig.write_digital(1);utime.sleep_us(10);trig.write_digital(0);duration=_f2(echo,1,_g9*_g10)\n\t\tif duration>0:d=duration;break\n\treturn round(d/_g10)",
    "mbrobot": "from microbit import i2c,pin1,pin2,pin8,pin12,pin13,pin14,pin15,sleep\nimport gc,machine,music,neopixel\n_g1=50\n_g2=40\n_g3=40\n_g4=bytearray(5)\n_g5=bytearray(2)\n_g6=bytes(b'\\x00\\x0b\\x0b\\x0c\\x0c\\r\\r\\r\\x0e\\x0e\\x0f\\x0f\\x0f\\x10\\x10\\x11\\x11\\x11\\x12\\x12\\x13\\x13\\x13\\x14\\x14\\x15\\x15\\x15\\x16\\x16\\x17\\x17\\x17\\x18\\x19\\x1a\\x1b\\x1b\\x1c\\x1d\\x1e\\x1f !\"##$%&\\'()*++,-./0123468:<?ADFILOSVZ^bgkpu{\\x81\\x87\\x8d\\x94\\x9b\\xa3\\xab\\xb4\\xbd\\xc6\\xd0\\xdb\\xe6\\xf2\\xff')\n_g7=0\n_g8=0\n_g9=0\n_g10=neopixel.NeoPixel(pin15,4)\nnp_rgb_pixels=_g10\n_g11=['c5:1','r','c5:1','r:3']\n_g12='Please connect to Maqueen robot and switch it on.'\ndef _f1(dirL,powerL,dirR,powerR):\n\tglobal _g4;_g4[1]=dirL;_g4[2]=powerL;_g4[3]=dirR;_g4[4]=powerR\n\ttry:i2c.write(16,_g4)\n\texcept:raise RuntimeError(_g12)\ndef _f2(side,dir,power):\n\tglobal _g4;_g4[1+side]=dir;_g4[2+side]=power\n\ttry:i2c.write(16,_g4)\n\texcept:raise RuntimeError(_g12)\ndef _f3(speed,offset):return min(_g6[speed]+offset,255)\ndef _f4(r):\n\tA=_g1;B=int(r*100);D=A-max(B+20,40)\n\tif D<=0:A=min(max(B+40,40),100)\n\tC=0\n\tif B>=4:E=(100-A)//2;C=(B*10-35)/(B*(11+(_g9-4)/10)+90+E);C=C*A\n\tF=_f3(int(C),0);G=_f3(int(A),0);return F,G\ndef calibrate(offset,differential=0,arcScaling=0):global _g8;global _g7;global _g9;_g7=max(min(int(offset),50),-10);_g8=max(min(int(differential),150),-150);_g9=max(min(arcScaling,50),-15);setSpeed(_g1)\ndef setSpeed(speed):\n\tglobal _g1;global _g2;global _g3;_g1=int(min(max(speed,0),100));A=_f3(_g1,_g7);B=round((1-_g1/100)*abs(_g8))if _g1>0 else 0;C=round(_g1/100*abs(_g8))\n\tif _g8>0:_g2=A-C;_g3=A+B\n\telse:_g2=A+B;_g3=A-C\ndef resetSpeed():setSpeed(50)\ndef stop():_f1(0,0,0,0)\ndef forward():_f1(0,_g2,0,_g3)\ndef backward():_f1(1,_g2,1,_g3)\ndef left():_f1(1,_g2,0,_g3)\ndef right():_f1(0,_g2,1,_g3)\ndef rightArc(radius):A,B=_f4(radius);_f1(0,B,0,A)\ndef leftArc(radius):A,B=_f4(radius);_f1(0,A,0,B)\nclass Motor:\n\tdef __init__(A,side):A._side=side\n\tdef rotate(B,speed):A=speed;C=int(min(max(abs(A),0),100));D=_f3(C,_g7);E=0 if A>0 else 1;_f2(B._side,E,D)\ndef setServo(servo,angle):\n\tB=angle;A=servo;global _g5\n\tif A=='S1'or A=='P0':_g5[0]=20\n\telif A=='S2'or A=='P1':_g5[0]=21\n\telse:raise ValueError(\"Unknown Servo. Please use 'S1' or 'S2'.\")\n\tif B<0 or B>180:raise ValueError('Invalid angle. Must be between 0 and 180')\n\t_g5[1]=B\n\ttry:i2c.write(16,_g5)\n\texcept:raise RuntimeError(_g12)\nclass IRSensor:\n\tdef __init__(A,pin):A._pin=pin\n\tdef read_digital(A):return A._pin.read_digital()\n\tdef read_analog(A):raise NameError('Maqueen Lite does not support reading analog sensor values.')\ndef getDistance():pin1.write_digital(1);pin1.write_digital(0);A=machine.time_pulse_us(pin2,1,50000);B=(A>>6)+(A>>10)+(A>>11)+(A>>12)+1;return max(min(B,500),0)if B>0 else 255\ndef setLED(state,stateR=None):B=state;A=stateR;A=A if A!=None else B;pin8.write_digital(B);pin12.write_digital(A)\ndef setLEDLeft(state):pin8.write_digital(state)\ndef setLEDRight(state):pin12.write_digital(state)\ndef fillRGB(red,green,blue):\n\tfor A in range(4):_g10[A]=red,green,blue\n\t_g10.show()\ndef clearRGB():_g10.clear()\ndef setRGB(position,red,green,blue):\n\tA=position\n\tif A<0 or A>3:raise ValueError('invalid RGB-LED position. Must be 0,1,2 or 3.')\n\t_g10[A]=red,green,blue;_g10.show()\ndef setAlarm(state):\n\tif state:music.play(_g11,wait=False,loop=True)\n\telse:music.stop()\ndef beep():music.pitch(440,200,wait=False)\npin2.set_pull(pin2.NO_PULL)\ndelay=sleep\nirLeft=IRSensor(pin13)\nirRight=IRSensor(pin14)\nmotL=Motor(0)\nmotR=Motor(2)",
    "mbrobotmot": "import gc\nfrom microbit import i2c,pin1,pin2,pin8,pin12,pin13,pin14,sleep\nimport machine\nclass Motor:\n\tdef __init__(A,id):A._id=2*id\n\tdef rotate(A,s):\n\t\tB=abs(s)\n\t\tif s>0:A._f2(0,B)\n\t\telif s<0:A._f2(1,B)\n\t\telse:A._f2(0,0)\n\tdef _f2(A,d,s):\n\t\ttry:i2c.write(16,bytearray([A._id,d,s]))\n\t\texcept:\n\t\t\tprint('Please switch on mbRobot!')\n\t\t\twhile True:0\ndelay=sleep\ndef getDistance():pin1.write_digital(1);pin1.write_digital(0);B=machine.time_pulse_us(pin2,1,50000);A=int(B/58.2+.5);return A if A>0 else 255\ndef setLED(on):pin8.write_digital(on);pin12.write_digital(on)\npin2.set_pull(pin2.NO_PULL)\nirLeft=pin13\nirRight=pin14\nledLeft=pin8\nledRight=pin12\nmotL=Motor(0)\nmotR=Motor(1)",
    "mbrobot_legacy": "import gc\nfrom microbit import i2c,pin1,pin2,pin8,pin12,pin13,pin14,sleep\nimport machine\n_g1=.097\ndef w(d1,d2,s1,s2):\n\ttry:i2c.write(16,bytearray([0,d1,s1]));i2c.write(16,bytearray([2,d2,s2]))\n\texcept:\n\t\tprint('Please switch on mbRobot!')\n\t\twhile True:0\ndef setSpeed(speed):\n\tA=speed;global _g2\n\tif A<20:_g2=A+5\n\telse:_g2=A\ndef forward():w(0,0,_g2,_g2)\ndef backward():w(1,1,_g2,_g2)\ndef stop():w(0,0,0,0)\ndef right():w(0 if _g2>0 else 1,1 if _g2>0 else 0,int(_g2*.9),int(_g2*.9))\ndef left():w(1 if _g2>0 else 0,0 if _g2>0 else 1,int(_g2*.9),int(_g2*.9))\ndef rightArc(r):\n\tA=abs(_g2)\n\tif r<_g1:B=0\n\telse:C=(r-_g1)/(r+_g1)*(1-A*A/200000);B=int(C*A)\n\tif _g2>0:w(0,0,A,B)\n\telse:w(1,1,B,A)\ndef leftArc(r):\n\tA=abs(_g2)\n\tif r<_g1:B=0\n\telse:C=(r-_g1)/(r+_g1)*(1-A*A/200000);B=int(C*A)\n\tif _g2>0:w(0,0,B,A)\n\telse:w(1,1,A,B)\nexit=stop\ndelay=sleep\ndef getDistance():pin1.write_digital(1);pin1.write_digital(0);B=machine.time_pulse_us(pin2,1,50000);A=int(B/58.2+.5);return A if A>0 else 255\ndef setLED(on):pin8.write_digital(on);pin12.write_digital(on)\ndef setServo(S,Angle):\n\tif S=='S1':A=20\n\tif S=='S2':A=21\n\tB=A,Angle;i2c.write(16,bytes(B))\npin2.set_pull(pin2.NO_PULL)\n_g2=50\nirLeft=pin13\nirRight=pin14\nledLeft=pin8\nledRight=pin12\nforward()",
    "mbrobot_plus": "_A='Please switch on mbRobot!'\nfrom microbit import i2c,pin0,pin1,pin2,sleep\nimport machine,gc,music\n_g1=50\n_g2=.082\ndef w(d1,d2,s1,s2):\n\ttry:i2c.write(16,bytearray([0,d1,d2,s1,s2]))\n\texcept:print(_A)\ndef setSpeed(speed):\n\tA=speed;global _g1\n\tif A<30 and A!=0:setPID(1);_g1=A+30\n\telif A>=30 and A<32:setPID(0);_g1=A+2\n\telse:setPID(0);_g1=A\ndef setPID(pd):i2c.write(16,bytearray([10,pd]))\ndef stop():setPID(0);w(0,0,0,0)\ndef resetSpeed():setPID(0);A=50\ndef forward():w(1,_g1,1,_g1)\ndef backward():w(2,_g1,2,_g1)\ndef left():A=1.825-.0175*_g1;w(2,int(_g1*A),1,int(_g1*A))\ndef right():A=1.825-.0175*_g1;w(1,int(_g1*A),2,int(_g1*A))\ndef rightArc(r):\n\tA=abs(_g1)\n\tif r<_g2:B=0\n\telse:C=(r-_g2)/(r+_g2)*(1-A*A/200000);B=int(C*A)\n\tif _g1>0:w(1,A,1,B)\n\telse:w(2,B,2,A)\ndef leftArc(r):\n\tA=abs(_g1)\n\tif r<_g2:B=0\n\telse:C=(r-_g2)/(r+_g2)*(1-A*A/200000);B=int(C*A)\n\tif _g1>0:w(1,B,1,A)\n\telse:w(2,A,2,B)\ndef getDistance():pin1.write_digital(1);pin1.write_digital(0);B=machine.time_pulse_us(pin2,1,50000);A=int(B/58.2-.5);return A if A>0 else 255\nclass Motor:\n\tdef __init__(A,id):A._id=2*id\n\tdef _f2(A,d,s):\n\t\ttry:i2c.write(16,bytearray([A._id,d,s]))\n\t\texcept:\n\t\t\tprint(_A)\n\t\t\twhile True:0\n\tdef rotate(A,s):\n\t\tB=abs(s)\n\t\tif s>0:A._f2(1,B)\n\t\telif s<0:A._f2(2,B)\n\t\telse:A._f2(0,0)\nclass LEDState:OFF=0;RED=1;GREEN=2;YELLOW=3;BLUE=4;PINK=5;CYAN=6;WHITE=7\ndef setLED(state,stateR=None):B=state;A=stateR;A=A or B;i2c.write(16,bytearray([11,B,A]))\ndef setLEDLeft(state):i2c.write(16,bytearray([11,state]))\ndef setLEDRight(state):i2c.write(16,bytearray([12,state]))\ndef setAlarm(on):\n\tif on:music.play(_g3,wait=False,loop=True)\n\telse:music.stop()\ndef beep():music.pitch(2000,200,wait=False)\ndef ir_read_values_as_byte():i2c.write(16,bytearray([29]));A=i2c.read(16,1);return~A[0]\ndef setServo(S,Angle):\n\tif S=='S1':A=20\n\tif S=='S2':A=21\n\tB=A,Angle;i2c.write(16,bytes(B))\nclass IR:L3=0;L2=1;L1=2;R1=3;R2=4;R3=5;masks=[1,2,4,8,16,32]\nclass IRSensor:\n\tdef __init__(A,index):A.index=index\n\tdef read_digital(A):B=ir_read_values_as_byte();return(B&IR.masks[A.index])>>A.index\nirLeft=IRSensor(IR.L1)\nirRight=IRSensor(IR.R1)\nirL1=IRSensor(IR.L1)\nirR1=IRSensor(IR.R1)\nirL2=IRSensor(IR.L2)\nirR2=IRSensor(IR.R2)\nirL3=IRSensor(IR.L3)\nirR3=IRSensor(IR.R3)\npin2.set_pull(pin2.NO_PULL)\nmotL=Motor(0)\nmotR=Motor(1)\ndelay=sleep\n_g3=['c6:1','r','c6,1','r','r','r']",
    "mbrobot_plusV2": "from microbit import i2c,pin0,pin1,pin2,pin13,pin14,pin15,sleep\nimport gc,machine,music,neopixel\n_g1=50\n_g2=50\n_g3=50\n_g4=bytearray(5)\n_g5=bytes(b'\\x00\\x0f\\x10\\x10\\x11\\x12\\x12\\x13\\x13\\x14\\x15\\x15\\x16\\x16\\x17\\x18\\x18\\x19\\x19\\x1a\\x1b\\x1b\\x1c\\x1c\\x1d\\x1e\\x1e\\x1f\\x1f !!\"\"#$$%%&\\')*+,-./0123456789:;;<>?ACEGIKMPRUX[^aeimquz\\x7f\\x84\\x89\\x8f\\x95\\x9b\\xa2\\xa9\\xb1\\xb9\\xc1\\xca\\xd3\\xdd\\xe8\\xf3\\xff')\n_g6=0\n_g7=0\n_g8=0\n_g9=25\n_g10=131\n_g11=bytearray(b'\\x0b\\x00\\x00')\n_g12=neopixel.NeoPixel(pin15,4)\nnp_rgb_pixels=_g12\n_g13=['c5:1','r','c5,1','r:3']\n_g14='Please connect to Maqueen robot and switch it on.'\ndef _f1(dirL,powerL,dirR,powerR):\n\tglobal _g4;_g4[1]=dirL;_g4[2]=powerL;_g4[3]=dirR;_g4[4]=powerR\n\ttry:i2c.write(16,_g4)\n\texcept:raise RuntimeError(_g14)\ndef _f2(side,dir,power):\n\tglobal _g4;_g4[1+side]=dir;_g4[2+side]=power\n\ttry:i2c.write(16,_g4)\n\texcept:raise RuntimeError(_g14)\ndef _f3(speed,offset):return min(_g5[speed]+offset,255)\ndef _f4(r):\n\tB=int(r*100);A=_g1\n\tif A<25:A=25\n\tH=min(abs(A-70),20)/20;C=0\n\tif B>5:\n\t\tD=A*(3*_g8-A-9*B+220);E=-14*_g8+A-200+3*A-10*B-290;C=int(D/E)\n\t\tif C<2:C=2 if B>15 else 1\n\tF=_f3(int(C),0);G=_f3(int(A),0);return F,G\ndef calibrate(offset,differential=0,arcScaling=0):global _g7;global _g6;global _g8;_g6=max(min(int(offset),50),-14);_g7=max(min(int(differential),150),-150);_g8=max(min(arcScaling,50),-50);setSpeed(_g1)\ndef setSpeed(speed):\n\tglobal _g1;global _g2;global _g3;_g1=int(min(max(speed,0),100));A=_f3(_g1,_g6);B=round((1-_g1/100)*abs(_g7))if _g1>0 else 0;C=round(_g1/100*abs(_g7))\n\tif _g7>0:_g2=A-C;_g3=A+B\n\telse:_g2=A+B;_g3=A-C\ndef resetSpeed():setSpeed(50)\ndef stop():_f1(0,0,0,0)\ndef forward():_f1(0,_g2,0,_g3)\ndef backward():_f1(1,_g2,1,_g3)\ndef left():_f1(1,_g2,0,_g3)\ndef right():_f1(0,_g2,1,_g3)\ndef rightArc(radius):A,B=_f4(radius);_f1(0,B,0,A)\ndef leftArc(radius):A,B=_f4(radius);_f1(0,A,0,B)\nclass Motor:\n\tdef __init__(A,side):A._side=side\n\tdef rotate(B,speed):A=speed;C=int(min(max(abs(A),0),100));D=_f3(C,_g6);E=0 if A>0 else 1;_f2(B._side,E,D)\ndef setServo(servo,angle):\n\tD=angle;A=servo\n\tif A=='P0'or A=='S1':B=pin0\n\telif A=='P1'or A=='S2':B=pin1\n\telif A=='P2':B=pin2\n\telse:raise ValueError(\"Unknown Servo. Please use 'P0', 'P1' or 'P2'.\")\n\tif D<0 or D>180:raise ValueError('Invalid angle. Must be between 0 and 180')\n\tC=(_g10-_g9)*int(D);E=(C>>8)+(C>>10)+(C>>11)+(C>>12);F=_g9+E;B.set_analog_period(20);B.write_analog(F)\ndef setMinAngleVal(duty):global _g9;_g9=int(duty)\ndef setMaxAngleVal(duty):global _g10;_g10=int(duty)\nclass IRSensor:\n\t_g21=bytes(b'\\x1d')\n\tdef __init__(A,index):A._index=index\n\tdef read_digital(A):\n\t\ttry:i2c.write(16,IRSensor._g21)\n\t\texcept:raise RuntimeError(_g14)\n\t\tB=~i2c.read(16,1)[0];return(B&2**A._index)>>A._index\n\tdef read_analog(A):\n\t\ttry:i2c.write(16,IRSensor._g21)\n\t\texcept:raise RuntimeError(_g14)\n\t\tB=i2c.read(16,11);return B[1+A._index*2]\ndef ir_read_values_as_byte():i2c.write(16,bytearray([29]));A=i2c.read(16,1);return~A[0]\ndef getDistance():pin13.write_digital(1);pin13.write_digital(0);A=machine.time_pulse_us(pin14,1,50000);B=(A>>6)+(A>>10)+(A>>11)+(A>>12)+1;return max(min(B,500),0)if B>0 else 255\ndef setLED(state,stateR=None):B=state;A=stateR;global _g11;A=A if A!=None else B;_g11[1]=B;_g11[2]=A;i2c.write(16,_g11)\ndef setLEDLeft(state):global _g11;_g11[1]=state;i2c.write(16,_g11)\ndef setLEDRight(state):global _g11;_g11[2]=state;i2c.write(16,_g11)\ndef fillRGB(red,green,blue):\n\tfor A in range(4):_g12[A]=red,green,blue\n\t_g12.show()\ndef clearRGB():_g12.clear()\ndef setRGB(position,red,green,blue):\n\tA=position\n\tif A<0 or A>3:raise ValueError('invalid RGB-LED position. Must be 0,1,2 or 3.')\n\t_g12[A]=red,green,blue;_g12.show()\ndef setAlarm(state):\n\tif state:music.play(_g13,wait=False,loop=True)\n\telse:music.stop()\ndef beep():music.pitch(440,200,wait=False)\nclass LEDState:ON=1;OFF=0;RED=1\nclass IR:R2=0;R1=1;M=2;L1=3;L2=4;masks=[1,2,4,8,16]\npin2.set_pull(pin2.NO_PULL)\ndelay=sleep\nirR2=IRSensor(0)\nirR1=IRSensor(1)\nirRight=irR1\nirM=IRSensor(2)\nirL1=IRSensor(3)\nirLeft=irL1\nirL2=IRSensor(4)\nmotL=Motor(0)\nmotR=Motor(2)",
    "mbthetabot": "from microbit import*\nfrom utime import ticks_us,sleep_us\nfrom neopixel import*\n_g1=50\n_g2=40\n_g3=40\n_g4=bytes(b'\\x00\\x0b\\x0b\\x0c\\x0c\\r\\r\\r\\x0e\\x0e\\x0f\\x0f\\x0f\\x10\\x10\\x11\\x11\\x11\\x12\\x12\\x13\\x13\\x13\\x14\\x14\\x15\\x15\\x15\\x16\\x16\\x17\\x17\\x17\\x18\\x19\\x1a\\x1b\\x1b\\x1c\\x1d\\x1e\\x1f !\"##$%&\\'()*++,-./0123468:<?ADFILOSVZ^bgkpu{\\x81\\x87\\x8d\\x94\\x9b\\xa3\\xab\\xb4\\xbd\\xc6\\xd0\\xdb\\xe6\\xf2\\xff')\n_g5=0\n_g6=0\n_g7=0\n_g8=34\n_g9=14\ndef _f1(dirL,powerL,dirR,powerR):pinsL=pin14,pin13;pinsR=pin16,pin15;pinsL[dirL].write_analog(powerL);pinsL[1-dirL].write_analog(0);pinsR[dirR].write_analog(powerR);pinsR[1-dirR].write_analog(0)\ndef _f2(side,direction,power):\n\tif side==0:pins=pin14,pin13\n\telif side==2:pins=pin16,pin15\n\tpins[direction].write_analog(power);pins[1-direction].write_analog(0)\ndef _f3(r):\n\touterSpeed=_g1;rCm=int(r*100);threshold=outerSpeed-max(rCm+20,40)\n\tif threshold<=0:outerSpeed=min(max(rCm+40,40),100)\n\treducedSpeed=0\n\tif rCm>=4:flattening=(100-outerSpeed)//2;reducedSpeed=(rCm*10-35)/(rCm*(11+(_g7-4)/10)+90+flattening);reducedSpeed=reducedSpeed*outerSpeed\n\tinnerByte=_f4(int(reducedSpeed),0);outerByte=_f4(int(outerSpeed),0);return innerByte,outerByte\ndef calibrate(offset,differential=0,arcScaling=0):global _g6;global _g5;global _g7;_g5=max(min(int(offset),150),-10);_g6=max(min(int(differential),150),-150);_g7=max(min(arcScaling,50),-15);setSpeed(_g1)\ndef setSpeed(speed):\n\tglobal _g1;global _g2;global _g3;_g1=int(min(max(speed,0),100));powerByte=_f4(_g1,_g5);boost=round((1-_g1/100)*abs(_g6))if _g1>0 else 0;reduction=round(_g1/100*abs(_g6))\n\tif _g6>0:_g2=powerByte-reduction;_g3=powerByte+boost\n\telse:_g2=powerByte+boost;_g3=powerByte-reduction\ndef _f4(speed,offset):speedIndex=int(speed*(len(_g4)-1)/100);return min(_g4[speedIndex]+offset,1023)\ndef stop():_f1(0,0,0,0)\ndef forward():_f1(0,_g2,0,_g3)\ndef backward():_f1(1,_g2,1,_g3)\ndef left():_f1(1,_g2,0,_g3)\ndef right():_f1(0,_g2,1,_g3)\ndef rightArc(radius):inner,outer=_f3(radius);_f1(0,outer,0,inner)\ndef leftArc(radius):inner,outer=_f3(radius);_f1(0,inner,0,outer)\ndef getDistance():\n\tpin12.write_digital(1);sleep_us(10);pin12.write_digital(0);pin12.set_pull(pin15.NO_PULL)\n\twhile pin12.read_digital()==0:0\n\tstart=ticks_us()\n\twhile pin12.read_digital()==1:0\n\tend=ticks_us();echo=end-start;distance=int(.01715*echo);return distance\ndef setLED(position,red,green,blue):global _g8;i2c_data=bytearray(5);i2c_data[0]=1;i2c_data[1]=position;i2c_data[2]=red;i2c_data[3]=green;i2c_data[4]=blue;i2c.write(_g8,i2c_data)\ndef fill(red,green,blue):\n\tfor position in range(_g9):setLED(position,red,green,blue)\ndef readLine(side):i2c.write(_g8,bytearray([side+1]),False);result=i2c.read(_g8,2);result=result[0]+(result[1]<<8);return result\ndef readLight(side):i2c.write(_g8,bytearray([side+3]),False);result=i2c.read(_g8,2);result=result[0]+(result[1]<<8);return result",
    "mbwait": "from microbit import button_a,button_b,pin0,pin1,pin2,pin_logo,sleep\nPOLLING_DELAY=100\ndef wait_for_press(button='any'):\n\tA=button;button_a.was_pressed();button_b.was_pressed()\n\tif A=='a'or A=='A':\n\t\twhile not button_a.was_pressed():sleep(POLLING_DELAY)\n\telif A=='b'or A=='B':\n\t\twhile not button_b.was_pressed():sleep(POLLING_DELAY)\n\telif A=='any'or A=='ANY':\n\t\twhile not button_a.was_pressed()and not button_b.was_pressed():sleep(POLLING_DELAY)\n\telif A=='both'or A=='ab'or A=='AB':\n\t\twhile not(button_a.is_pressed()and button_b.is_pressed()):sleep(POLLING_DELAY)\n\t\twhile button_a.is_pressed()or button_b.is_pressed():sleep(POLLING_DELAY)\n\telse:raise RuntimeError(\"Button to wait for must be either: 'a', 'b', 'any' or 'both'.\")\ndef wait_for_touch(pin='logo'):\n\tB=pin;A=pin_logo\n\tif B=='pin0':A=pin0\n\telif B=='pin1':A=pin1\n\telif B=='pin2':A=pin2\n\telif B=='logo'or B=='pin_logo'or B=='pinLogo':A=pin_logo\n\telse:raise RuntimeError(\"Argument 'pin' must be one of: 'pin_logo', 'pin0', 'pin1' or 'pin2'.\")\n\tA.set_touch_mode(A.CAPACITIVE)\n\twhile not A.is_touched():sleep(POLLING_DELAY)",
    "mbxgo": "from microbit import*\n_g1=50\n_g2=False\n_g3=pin14\n_g4=pin13\ndef checkInit(func):\n\tdef wrapper(*args,**kwargs):\n\t\tglobal _g2\n\t\tif not _g2:init_xgo_serial(_g3,_g4)\n\t\treturn func(*args,**kwargs)\n\treturn wrapper\ndef _f1(speed,in_min,in_max,out_min,out_max):return(speed-in_min)*(out_max-out_min)//(in_max-in_min)+out_min\n@checkInit\ndef _f2(direction,speed):\n\tmove_buffer=bytearray(9);move_buffer[0]=85;move_buffer[1]=0;move_buffer[2]=9;move_buffer[3]=0;move_buffer[7]=0;move_buffer[8]=170;speed=max(0,min(100,speed))\n\tif direction==0:move_buffer[4]=48;move_buffer[5]=_f1(speed,0,100,128,255)\n\telif direction==1:move_buffer[4]=48;move_buffer[5]=_f1(speed,0,100,128,0)\n\telif direction==2:move_buffer[4]=49;move_buffer[5]=_f1(speed,0,100,128,0)\n\telif direction==3:move_buffer[4]=49;move_buffer[5]=_f1(speed,0,100,128,255)\n\tmove_buffer[6]=~(9+move_buffer[4]+move_buffer[5])&255;uart.write(move_buffer)\n@checkInit\ndef clampX(milimeters=50):clampBuffer=bytearray(9);clampBuffer[0]=85;clampBuffer[1]=0;clampBuffer[2]=9;clampBuffer[3]=0;clampBuffer[4]=115;clampBuffer[7]=0;clampBuffer[8]=170;clampBuffer[5]=milimeters;clampBuffer[6]=~(124+clampBuffer[5])&255;uart.write(clampBuffer);sleep(1000)\n@checkInit\ndef clampZ(milimeters=50):clampBuffer=bytearray(9);clampBuffer[0]=85;clampBuffer[1]=0;clampBuffer[2]=9;clampBuffer[3]=0;clampBuffer[4]=116;clampBuffer[7]=0;clampBuffer[8]=170;clampBuffer[5]=milimeters;clampBuffer[6]=~(125+clampBuffer[5])&255;uart.write(clampBuffer);sleep(1000)\n@checkInit\ndef clamp(force):clampBuffer=bytearray(9);clampBuffer[0]=85;clampBuffer[1]=0;clampBuffer[2]=9;clampBuffer[3]=0;clampBuffer[4]=113;clampBuffer[7]=0;clampBuffer[8]=170;clampBuffer[5]=force;clampBuffer[6]=~(122+clampBuffer[5])&255;uart.write(clampBuffer);sleep(1000)\ndef init_xgo_serial(tx_pin,rx_pin,baudrate=115200):global _g2;uart.init(baudrate=baudrate,tx=tx_pin,rx=rx_pin);init_action();_g2=True\ndef init_action():commands_buffer=bytearray(9);commands_buffer[0]=85;commands_buffer[1]=0;commands_buffer[2]=9;commands_buffer[3]=0;commands_buffer[4]=62;commands_buffer[5]=255;commands_buffer[6]=~326&255;commands_buffer[7]=0;commands_buffer[8]=170;uart.write(commands_buffer);sleep(2000)\n@checkInit\ndef action(id):commands_buffer=bytearray(9);commands_buffer[0]=85;commands_buffer[1]=0;commands_buffer[2]=9;commands_buffer[3]=0;commands_buffer[4]=62;commands_buffer[5]=id;commands_buffer[6]=~(71+id)&255;commands_buffer[7]=0;commands_buffer[8]=170;uart.write(commands_buffer);sleep(2000)\ndef changeInit(tx,rx):global _g3;global _g4;_g3=tx;_g4=rx;init_xgo_serial(_g3,_g4)\n@checkInit\ndef setSpeed(speed):global _g1;_g1=speed\ndef forward():_f2(0,_g1)\ndef backward():_f2(1,_g1)\ndef left():_f2(2,_g1)\ndef right():_f2(3,_g1)"
}