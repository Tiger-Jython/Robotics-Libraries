{
    "callibot": "_B=True\n_A='Please switch on Robot!'\nimport gc\nfrom calliope_mini import i2c,sleep\n_g1=.06\ndef w(d1,d2,s1,s2):\n\ttry:i2c.write(32,bytearray([0,d1,s1]));i2c.write(32,bytearray([2,d2,s2]))\n\texcept:\n\t\tprint(_A)\n\t\twhile _B:0\ndef setSpeed(speed):global _g2;_g2=speed+40\ndef forward():w(0,0,_g2,_g2)\ndef backward():w(1,1,_g2,_g2)\ndef stop():w(0,0,0,0)\ndef right():A=int(_g2*1.1);w(0 if _g2>0 else 1,1 if _g2>0 else 0,A,A)\ndef left():A=int(_g2*1.1);w(1 if _g2>0 else 0,0 if _g2>0 else 1,A,A)\ndef rightArc(r):\n\tA=abs(_g2)\n\tif r<_g1:B=0\n\telse:C=(r-_g1)/(r+_g1)*(1-A*A/200000);B=int(C*A)\n\tif _g2>0:w(0,0,A,B)\n\telse:w(1,1,B,A)\ndef leftArc(r):\n\tA=abs(_g2)\n\tif r<_g1:B=0\n\telse:C=(r-_g1)/(r+_g1)*(1-A*A/200000);B=int(C*A)\n\tif _g2>0:w(0,0,B,A)\n\telse:w(1,1,A,B)\ndef setLEDLeft(on):\n\ttry:i2c.write(33,bytearray([0,0]))\n\texcept:\n\t\tprint(_A)\n\t\twhile _B:0\n\tif on==1:i2c.write(33,bytearray([0,1]))\n\telse:i2c.write(33,bytearray([0,0]))\ndef setLEDRight(on):\n\ttry:i2c.write(33,bytearray([0,0]))\n\texcept:\n\t\tprint(_A)\n\t\twhile _B:0\n\tif on==1:i2c.write(33,bytearray([0,2]))\n\telse:i2c.write(33,bytearray([0,0]))\ndef setLED(on):\n\ttry:i2c.write(33,bytearray([0,0]))\n\texcept:\n\t\tprint(_A)\n\t\twhile _B:0\n\tif on==1:i2c.write(33,bytearray([0,3]))\n\telse:i2c.write(33,bytearray([0,0]))\ndef irLeftValue():\n\ttry:\n\t\tA=i2c.read(33,1)\n\t\tif A[0]==130 or A[0]==131:return 1\n\t\telse:return 0\n\texcept:\n\t\tprint(_A)\n\t\twhile _B:0\ndef irRightValue():\n\ttry:\n\t\tA=i2c.read(33,1)\n\t\tif A[0]==129 or A[0]==131:return 1\n\t\telse:return 0\n\texcept:\n\t\tprint(_A)\n\t\twhile _B:0\ndef getDistance():\n\ttry:A=i2c.read(33,3);B=(256*A[1]+A[2])/10;return B\n\texcept:\n\t\tprint(_A)\n\t\twhile _B:0\ndef tsValue():\n\ttry:\n\t\tA=i2c.read(33,1)\n\t\tif A[0]==140 or A[0]==143:return 1\n\t\telse:return 0\n\texcept:\n\t\tprint(_A)\n\t\twhile _B:0\ndef tsLeftValue():\n\ttry:\n\t\tA=i2c.read(33,1)\n\t\tif A[0]==136 or A[0]==139:return 1\n\t\telse:return 0\n\texcept:\n\t\tprint(_A)\n\t\twhile _B:0\ndef tsRightValue():\n\ttry:\n\t\tA=i2c.read(33,1)\n\t\tif A[0]==132 or A[0]==135:return 1\n\t\telse:return 0\n\texcept:\n\t\tprint(_A)\n\t\twhile _B:0\nexit=stop\ndelay=sleep\n_g2=90",
    "callibotmot": "import gc\nfrom calliope_mini import i2c,sleep\nimport machine\nclass Motor:\n\tdef __init__(A,id):A._id=id\n\tdef _f2(B,d,s):\n\t\tif B._id==0:A=0\n\t\telse:A=2\n\t\ttry:i2c.write(32,bytearray([A,d,s]))\n\t\texcept:\n\t\t\tprint('Please switch on mbRobot!')\n\t\t\twhile True:0\n\tdef rotate(B,s):\n\t\tA=abs(s);A=A+50\n\t\tif s>0:B._f2(0,A)\n\t\telif s<0:B._f2(1,A)\n\t\telse:B._f2(0,0)\ndelay=sleep\ndef setLED(on):\n\tif on==1:i2c.write(33,bytearray([0,3]))\n\telse:i2c.write(33,bytearray([0,0]))\nmotL=Motor(0)\nmotR=Motor(2)",
    "callimk": "import gc\nfrom calliope_mini import i2c,sleep\ni2c.init()\n_g1=30\n_g2=.09\ndef w(d1,d2,s1,s2):i2c.write(16,bytearray([0,d1,s1]));i2c.write(16,bytearray([2,d2,s2]))\ndef forward():w(0,0,_g1,_g1)\ndef backward():w(1,1,_g1,_g1)\ndef stop():w(0,0,0,0)\ndef right():w(0 if _g1>0 else 1,1 if _g1>0 else 0,_g1,_g1)\ndef left():w(1 if _g1>0 else 0,0 if _g1>0 else 1,_g1,_g1)\ndef rightArc(r):\n\tA=abs(_g1)\n\tif r<_g2:B=0\n\telse:C=(r-_g2)/(r+_g2)*(1-A*A/200000);B=int(C*A)\n\tif _g1>0:w(0,0,A,B)\n\telse:w(1,1,B,A)\ndef leftArc(r):\n\tA=abs(_g1)\n\tif r<_g2:B=0\n\telse:C=(r-_g2)/(r+_g2)*(1-A*A/200000);B=int(C*A)\n\tif _g1>0:w(0,0,B,A)\n\telse:w(1,1,A,B)\ndef setSpeed(speed):\n\tA=speed;global _g1\n\tif A<15:_g1=15\n\telse:_g1=A\ndef motorL(dir,speed):i2c.write(16,bytearray([0,dir,speed]))\ndef motorR(dir,speed):i2c.write(16,bytearray([2,dir,speed]))\ndef led(right_left,on_off):\n\tA=bytearray(2)\n\tif right_left==0:A[0]=11\n\telse:A[0]=12\n\tA[1]=on_off;i2c.write(16,A)\ndef setLEDLeft(on):led(1,on)\ndef setLEDRight(on):led(0,on)\ndef setLED(on):led(1,on);led(0,on)\ndef rgbLED(red,green,blue):A=bytearray(2);A[0]=24;A[1]=red;B=bytearray(2);B[0]=25;B[1]=green;C=bytearray(2);C[0]=26;C[1]=blue;i2c.write(16,A);i2c.write(16,B);i2c.write(16,C)\ndef getDistance():i2c.write(16,bytearray([40]));sleep(20);A=i2c.read(16,2);B=A[0]<<8|A[1];return B\ndef irLeftValue():i2c.write(16,bytearray([29]));A=i2c.read(16,1)[0];return 0 if A&1!=0 else 1\ndef irRightValue():i2c.write(16,bytearray([29]));A=i2c.read(16,1)[0];return 0 if A&2!=0 else 1\ndef setServo(S,Angle):\n\tif S=='S1':A=20\n\tif S=='S2':A=21\n\ti2c.write(16,bytearray([A,Angle]))\nexit=stop\ndelay=sleep",
    "cbalarm": "import music\n_g1=['c6:1','r','c6,1','r','r','r']\ndef setAlarm(on):\n\tif on:music.play(_g1,wait=False,loop=True)\n\telse:music.stop()\ndef beep():music.pitch(2000,200,wait=False)",
    "cpglow": "from calliope_mini import*\n_g1=0\n_g2=0\n_g3=0\n_g4=50\n_g5=True\n_g6=False\ndef makeGlow():global _g6;display.set_pixel(2,2,9);_g6=True\ndef clear():display.clear()\ndef forward():_f1(1)\ndef back():_f1(-1)\ndef right(angle):global _g3;_g3=(_g3+angle)%360\ndef left(angle):right(-angle)\ndef setPos(x,y):global _g1,_g2;_g1=x;_g2=y;_f2()\ndef getPos():return _g1,_g2\ndef setSpeed(speed):global _g4;_g4=speed\ndef showTrace(enable):global _g5;_g5=enable\ndef isLit():return display.get_pixel(_g1+2,4-(_g2+2))==9\ndef _f1(s):\n\tglobal _g1,_g2;sleep(2000-_g4*20);d=_g3//45\n\tif d in[1,2,3]:_g1+=s\n\tif d in[5,6,7]:_g1-=s\n\tif d in[0,1,7]:_g2+=s\n\tif d in[3,4,5]:_g2-=s\n\t_f2()\ndef _f2():\n\tif not _g6:print('Use \"makeGlow()\" to create a Glow.');raise Exception('Glow not initialized.')\n\tif not _g5:display.clear()\n\tif-2<=_g1<=2 and-2<=_g2<=2:display.set_pixel(_g1+2,4-(_g2+2),9)",
    "cpmike": "from calliope_mini import pin3,running_time,sleep\n_g1=running_time()\ndef isClicked(level=10,rearm_time=500):\n\tA=False;global _g1\n\tif running_time()-_g1<rearm_time:sleep(10);return A\n\tB=pin3.read_analog()\n\tif B<518-level:_g1=running_time();return True\n\treturn A",
    "cprover": "from calliope_mini import pin28,pin29,pin30\ndef forward():pin28.write_analog(v);pin29.write_digital(1);pin30.write_digital(1)\ndef left():pin28.write_analog(v);pin29.write_digital(0);pin30.write_digital(1)\ndef right():pin28.write_analog(v);pin29.write_digital(1);pin30.write_digital(0)\ndef stop():pin28.write_digital(0)\ndef move():left()\ndef rewind():right()\ndef setSpeed(speed):global v;v=int(speed/100*1023)\nsetSpeed(100)",
    "cputils": "def cat(filename):\n\twith open(filename)as B:\n\t\tA=B.readline()\n\t\twhile A:print(A[:-1]);A=B.readline()\nfrom math import asin,atan2,sqrt,degrees\ndef getPitch(a):A=atan2(a[1],a[2]);return int(degrees(A))\ndef getRoll(a):A=sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);B=asin(a[0]/A);return int(degrees(B))"
}